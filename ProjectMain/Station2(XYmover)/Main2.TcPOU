<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="Main2" Id="{cef6c1f9-2a01-4b71-81db-f7ed4deb6965}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM Main2
VAR	
	buffer					: ARRAY[1..4096] OF BYTE;
	path					: MC_PATH_DATA_REF(ADR(buffer), SIZEOF(buffer));
	
	aTargetPos				: ARRAY[1..GVL_XY.cAxesCount] OF MC_LREAL;
	aTransitionParam		: ARRAY[1..2] OF MC_LREAL;
	
	fVelFactor				: LREAL := 1.0;
	
	fbPower					: FB_PowerAll;
	fbAddAllAxes			: FB_AddAllAxes;
	fbGroupEnable			: MC_GroupEnable;
	fbMoveLinPrep			: MC_MoveLinearAbsolutePreparation;
	fbMovePath				: MC_MovePath;
	fbStop					: MC_GroupStop;
	fbUngroupAxes			: MC_UngroupAllAxes;
	fbGroupReset			: MC_GroupReset;
	fbGroupReadStatus		: MC_GroupReadStatus;
	fbGroupSetOvr			: MC_GroupSetOverride;
	
	fbBlockerPrep			: MC_BlockerPreparation;
	fbBlockerRelease		: MC_ReleaseBlocker;
	fbBlockerReadStatus		: MC_GroupReadBlockerStatus;
	fbDwellTimePrep			: MC_DwellTimePreparation;
	
	fbConveyerTimer			: FB_ConveyerTimer;
	
	nState					: INT := -5;
	nNextState				: INT;
	bMovePrepError			: BOOL;
	bPickCycle				: BOOL := TRUE;
	bExecutePath			: BOOL := TRUE;
	
	bUserIncrementStep		: BOOL; // user can go to next step
	bUserInfiniteMovement 	: BOOL :=FALSE; // user can decide if only one movement is executed or infinite movement.
	bUserStop				: BOOL; // user triggered stop
	bUserForceUngroup		: BOOL; // user triggered ungroup axes
	bUserForceReset			: BOOL; // user triggered reset
	bUserReleaseBlocker		: BOOL; // user release the blocker
	fbGearIn: MC_GearIn;
	groupErrorID: UDINT;
	bsetOvrID: UDINT;
	fbPowerSlave: MC_Power;
	groupEnableErrorID: UDINT;
	iPickStation: INT := 1;
	airTimer				: TON;

	
	bUserInput: BOOL;
	bPathPrepared: BOOL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[fbConveyerTimer();

airTimer(
		IN := bUserInput,
		PT := T#0.5S );

fbGroupReadStatus(
	AxesGroup:= GVL_XY.stGroupRef , 
	Enable:= TRUE , 
	Valid=> , 
	Busy=> , 
	GroupMoving=> , 
	GroupHoming=> , 
	GroupErrorStop=> , 
	GroupNotReady=> , 
	GroupStandby=> , 
	GroupStopping=> , 
	GroupDisabled=> , 
	Error=> , 
	ErrorId=> groupErrorID);
	
IF fbGroupReadStatus.Error THEN
	nState := 9998;
ELSIF NOT fbGroupReadStatus.Valid THEN
	nState := 9999;	
END_IF

fbGroupSetOvr(
	AxesGroup:= GVL_XY.stGroupRef, 
	Enable:= TRUE, 
	VelFactor:= fVelFactor , 
	Enabled=> , 
	Busy=> , 
	Error=> , 
	ErrorId=> bsetOvrID, 
	ActualVelFactor=> );

IF fbGroupSetOvr.Error THEN
	nState := 9996;
END_IF
	
	

fbPowerSlave(
	Axis:= GVL_XY.stAxisXSlave, 
	Enable:= TRUE, 
	Enable_Positive:= TRUE, 
	Enable_Negative:= TRUE, 
	Override:= 100, 
	BufferMode:= , 
	Options:= , 
	Status=> , 
	Busy=> , 
	Active=> , 
	Error=> , 
	ErrorID=> );
fbPower();

CASE nState OF


-5:
	fbPower.Enable := TRUE;
	
	IF fbPower.Status THEN
		IF bUserIncrementStep THEN
			nNextState := nState +1;
			nState := 101;
		END_IF
	ELSIF	fbPower.Error THEN
		nState := nState +1000;	
	END_IF

-4:	
	IF bUserIncrementStep THEN
		nNextState := nState +1; 
		nState := 101;
		fbAddAllAxes(Execute:= FALSE);
		fbGroupEnable(AxesGroup:=GVL_XY.stGroupRef , Execute:=FALSE);
		fbMovePath(AxesGroup:=GVL_XY.stGroupRef ,PathData:=path ,Execute:= FALSE);
		bMovePrepError := FALSE;
	END_IF
	
-3:
	//Add all axes to group
	fbAddAllAxes(Execute:= TRUE);
	
	IF fbAddAllAxes.Done THEN
		IF bUserIncrementStep THEN
			fbAddAllAxes(Execute:= FALSE);
			nNextState := nState +1;
			nState := 101;
		END_IF
	ELSIF fbAddAllAxes.Error THEN
		nState := nState +1000;
	END_IF
	
-2:

	//Enable Group
	fbGroupEnable(AxesGroup:=GVL_XY.stGroupRef , Execute:=TRUE);
	
	IF fbGroupEnable.Done THEN
		IF bUserIncrementStep THEN
			fbGroupEnable(AxesGroup:=GVL_XY.stGroupRef , Execute:=FALSE);
			nNextState := nState +1;
			nState := 101;
		END_IF
	ELSIF fbGroupEnable.Error THEN
		groupEnableErrorID := fbGroupEnable.ErrorId;
		nState := nState +1000;
	END_IF
-1:
		 fbGearIn(
				Master:= GVL_XY.stAxis[1], 
				Slave:= GVL_XY.stAxisXSlave, 
				Execute:= TRUE , 
				RatioNumerator:= 1, 
				RatioDenominator:=1, 
				Acceleration:= , 
				Deceleration:= , 
				Jerk:= , 
				BufferMode:= , 
				Options:= , 
				InGear=> , 
				Busy=> , 
				Active=> , 
				CommandAborted=> , 
				Error=> , 
				ErrorID=> );	
	
		IF fbGearIn.InGear THEN
		IF bUserIncrementStep THEN
			nNextState := nState +1;
			nState := 101;
		END_IF
	ELSIF fbGearIn.Error THEN
		nState := nState +1000;
	END_IF

0:
	//Fill path table and start execution with fbMovePath
	IF bUserIncrementStep OR bUserInfiniteMovement THEN
		IF bPickCycle THEN 
			IF iPickStation = 1 AND GVL_XTS.mover3InPosition THEN
				iPickStation := 2;
				//Prepare table (MC_MoveLinearAbsolutePreparation)
				A_PreparePathPick_1();
				bPathPrepared := TRUE;

			ELSIF iPickStation = 2 AND GVL_XTS.mover2InPosition THEN
				iPickStation := 3;
				//Prepare table (MC_MoveLinearAbsolutePreparation)
				A_PreparePathPick_2();
				bPathPrepared := TRUE;
				
			ELSIF iPickStation = 3 AND GVL_XTS.mover1InPosition THEN
				iPickStation := 1;
				//Prepare table (MC_MoveLinearAbsolutePreparation)
				A_PreparePathPick_3();
				bPathPrepared := TRUE;
			END_IF

		ELSE
			//Prepare table (MC_MoveLinearAbsolutePreparation)	
			A_PreparePathPlace();
		END_IF	
		bPickCycle := NOT bPickCycle;		
		
		IF bMovePrepError THEN
			nState := nState +1000;
		ELSIF bPathPrepared THEN
			fbMovePath(AxesGroup:= GVL_XY.stGroupRef, PathData:= path, Execute:= FALSE);
			IF bUserInfiniteMovement THEN
				nState := nState +1;
				bPathPrepared := FALSE;
			ELSIF bUserIncrementStep THEN
				nNextState := nState + 1;
				nState := 101;
			END_IF				
		END_IF	
	END_IF	
	
1:
	
	

	//Execute prepared movement
	fbMovePath(
		AxesGroup:= GVL_XY.stGroupRef , 
		PathData:= path , 
		Execute:= bExecutePath
	);

	IF fbMovePath.Done THEN
		IF bUserIncrementStep THEN
			nNextState := 50;
			nState := 101;
			fbMovePath(AxesGroup:= GVL_XY.stGroupRef, PathData:= path, Execute:= FALSE);
		ELSIF bUserInfiniteMovement THEN
			nState := nState + 1;
			fbMovePath(AxesGroup:= GVL_XY.stGroupRef, PathData:= path, Execute:= FALSE);
		END_IF
	ELSIF fbMovePath.Error THEN
		nState := nState + 1000;	
	END_IF
	
2:
	
	IF NOT bPickCycle THEN
		bUserInput := TRUE;
		GVL_XY.bPullUp := FALSE;
		GVL_XY.bPushDown := TRUE;
		GVL_XY.bAirEnable := TRUE;
		IF airTimer.Q THEN
			bUserInput := FALSE;
			nState := nState + 1;
		END_IF
		
	ELSIF fbConveyerTimer.bReadyToPlace THEN
		GVL_XY.bAirEnable := FALSE;
		nState := 0;
	END_IF
	
3:
	bUserInput := TRUE;
	GVL_XY.bPushDown := FALSE;
	GVL_XY.bPullUp := TRUE;
	IF airTimer.Q THEN
		bUserInput := FALSE;
		nState := 0;
	END_IF
	
20:
	fbStop(AxesGroup:=GVL_XY.stGroupRef, Execute:= FALSE);
	fbStop(AxesGroup:=GVL_XY.stGroupRef, Execute:= TRUE, Jerk:= MC_IGNORE);
	nState := nState + 1;
21:
	fbStop(AxesGroup:=GVL_XY.stGroupRef,Execute:= TRUE);
	IF fbStop.Done THEN
		IF bUserIncrementStep THEN
			fbStop(AxesGroup:=GVL_XY.stGroupRef, Execute:= FALSE);
			nNextState := 0;
			nState := 101;
		END_IF 		
	ELSIF fbStop.Error THEN
		nState := nState +1000;
	END_IF
50:
	//Disable group and remove all axes 
	fbUngroupAxes(AxesGroup:= GVL_XY.stGroupRef, Execute:= FALSE);
	//Check that axes are not moving else we will get a position jump
	IF fbGroupReadStatus.GroupStandby OR fbGroupReadStatus.GroupErrorStop OR fbGroupReadStatus.GroupNotReady THEN
		fbUngroupAxes(AxesGroup:= GVL_XY.stGroupRef, Execute:= TRUE);
		nState := nState + 1;
	END_IF	
51:
	fbUngroupAxes(
		AxesGroup:= GVL_XY.stGroupRef , 
		Execute:= TRUE, 
		Done=> , 
		Busy=> , 
		Error=> , 
		ErrorId=> );
	
	IF fbUngroupAxes.Done THEN
		IF bUserIncrementStep THEN
			nNextState := -4;
			nState := 101;
		END_IF
	ELSIF fbUngroupAxes.Error THEN
		nState := nState +1000;
	END_IF
80:
	fbGroupReset(AxesGroup:= GVL_XY.stGroupRef , Execute:= FALSE);
	fbGroupReset(AxesGroup:= GVL_XY.stGroupRef , Execute:= TRUE);
	nState := nState +1;
81:	
	fbGroupReset(
		AxesGroup:= GVL_XY.stGroupRef , 
		Execute:= , 
		Done=> , 
		Busy=> , 
		Error=> , 
		ErrorId=> );
	
	IF fbGroupReset.Done THEN
		IF bUserIncrementStep THEN
			IF fbGroupReadStatus.GroupDisabled THEN
				nNextState := -4;
			ELSE
				nNextState := 0;
			END_IF
			nState := 101;
		END_IF				
	END_IF	
101:
	IF (bUserIncrementStep) THEN				
		nState := nNextState;
		bUserIncrementStep := FALSE;
	END_IF
1000..9999:
	
	IF NOT fbGroupReadStatus.Error AND NOT fbGroupSetOvr.Error THEN
		nState := -5;
	END_IF

	;//Error				
END_CASE

IF bUserStop THEN
	nState := 20;
	bUserStop := FALSE;
END_IF
IF bUserForceUngroup THEN
	nState := 50;
	bUserForceUngroup := FALSE;
END_IF
IF bUserForceReset THEN
	nState := 80;
	bUserForceReset := FALSE;
END_IF 
]]></ST>
    </Implementation>
    <Action Name="A_PreparePathPick_1" Id="{dcb08973-a115-429b-89e2-ef77d8cbb861}">
      <Implementation>
        <ST><![CDATA[path.ClearPath();  //Clear nodes that were in path

fbMoveLinPrep.Position						:= ADR(aTargetPos); //pointer to position array
fbMoveLinPrep.PositionCount 				:= GVL_XY.cAxesCount; //number of axes in group
fbMoveLinPrep.TransitionParameter			:= ADR (aTransitionParam); //pointer to transition parameter array
fbMoveLinPrep.TransitionParameterCount		:= 2; //number of transition parameters, has to be set always 2
fbMoveLinPrep.BufferMode					:= mcBlendingPrevious;
fbMoveLinPrep.TransitionMode				:= mcTransModeCornerDistanceAdvanced;
//Set dynamics to default values of the axes
fbMoveLinPrep.Acceleration					:= MC_DEFAULT;
fbMoveLinPrep.Deceleration					:= MC_DEFAULT;
fbMoveLinPrep.Jerk							:= MC_DEFAULT;

//1st node
aTargetPos[1]				:= 4;
aTargetPos[2]				:= 93;

aTransitionParam[1]			:= 0; //blending distance on previous segment, no influence here
aTransitionParam[2]			:= 0; //blending distance on this segment, no influence here
fbMoveLinPrep(PathData:= path , Velocity:= 3000, InvokeId:= 10);
bMovePrepError := bMovePrepError OR fbMoveLinPrep.Error;

]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_PreparePathPick_2" Id="{94184c41-b842-4066-830a-83c0336a87f7}">
      <Implementation>
        <ST><![CDATA[path.ClearPath();  //Clear nodes that were in path

fbMoveLinPrep.Position						:= ADR(aTargetPos); //pointer to position array
fbMoveLinPrep.PositionCount 				:= GVL_XY.cAxesCount; //number of axes in group
fbMoveLinPrep.TransitionParameter			:= ADR (aTransitionParam); //pointer to transition parameter array
fbMoveLinPrep.TransitionParameterCount		:= 2; //number of transition parameters, has to be set always 2
fbMoveLinPrep.BufferMode					:= mcBlendingPrevious;
fbMoveLinPrep.TransitionMode				:= mcTransModeCornerDistanceAdvanced;
//Set dynamics to default values of the axes
fbMoveLinPrep.Acceleration					:= MC_DEFAULT;
fbMoveLinPrep.Deceleration					:= MC_DEFAULT;
fbMoveLinPrep.Jerk							:= MC_DEFAULT;

//1st node
aTargetPos[1]				:= 107;
aTargetPos[2]				:= 93;

aTransitionParam[1]			:= 0; //blending distance on previous segment (InvokeId=10), defines when to leave line
aTransitionParam[2]			:= 0; //blending distance on this segment, defines latest positionn to be back  on line of InovkeId=20 
fbMoveLinPrep(PathData:= path , Velocity:= 3000, InvokeId:= 20); 
bMovePrepError := bMovePrepError OR fbMoveLinPrep.Error;
]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_PreparePathPick_3" Id="{cf55799c-df25-474f-a8a4-b05de27edb4a}">
      <Implementation>
        <ST><![CDATA[path.ClearPath();  //Clear nodes that were in path

fbMoveLinPrep.Position						:= ADR(aTargetPos); //pointer to position array
fbMoveLinPrep.PositionCount 				:= GVL_XY.cAxesCount; //number of axes in group
fbMoveLinPrep.TransitionParameter			:= ADR (aTransitionParam); //pointer to transition parameter array
fbMoveLinPrep.TransitionParameterCount		:= 2; //number of transition parameters, has to be set always 2
fbMoveLinPrep.BufferMode					:= mcBlendingPrevious;
fbMoveLinPrep.TransitionMode				:= mcTransModeCornerDistanceAdvanced;
//Set dynamics to default values of the axes
fbMoveLinPrep.Acceleration					:= MC_DEFAULT;
fbMoveLinPrep.Deceleration					:= MC_DEFAULT;
fbMoveLinPrep.Jerk							:= MC_DEFAULT;


aTargetPos[1]				:= 190;
aTargetPos[2]				:= 93;

aTransitionParam[1]			:= 0; 
aTransitionParam[2]			:= 0;
fbMoveLinPrep(PathData:= path , Velocity:= 3000, InvokeId:= 40);
bMovePrepError := bMovePrepError OR fbMoveLinPrep.Error;
]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_PreparePathPlace" Id="{807eb52d-d6c5-48fb-b361-4b935b271568}">
      <Implementation>
        <ST><![CDATA[path.ClearPath(); //Clear nodes that were in path

fbMoveLinPrep.Position						:= ADR(aTargetPos); //pointer to position array
fbMoveLinPrep.PositionCount 				:= GVL_XY.cAxesCount; //number of axes in group
fbMoveLinPrep.TransitionParameter			:= ADR (aTransitionParam); //pointer to transition parameter array
fbMoveLinPrep.TransitionParameterCount		:= 2; //number of transition parameters, has to be set always 2
fbMoveLinPrep.BufferMode					:= mcBlendingPrevious;
fbMoveLinPrep.TransitionMode				:= mcTransModeCornerDistanceAdvanced;
fbMoveLinPrep.Acceleration					:= MC_DEFAULT;
fbMoveLinPrep.Deceleration					:= MC_DEFAULT;
fbMoveLinPrep.Jerk							:= MC_DEFAULT;

aTargetPos[1]				:= 150;
aTargetPos[2]				:= 353;
				
aTransitionParam[1]			:= 0; //blending distance on previous segment, no influence here
aTransitionParam[2]			:= 0; //blending distance on this segment, no influence here
fbMoveLinPrep(PathData:= path , Velocity:= 3000, InvokeId:= 15);
bMovePrepError := bMovePrepError OR fbMoveLinPrep.Error; ]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="Main2">
      <LineId Id="1237" Count="0" />
      <LineId Id="1236" Count="0" />
      <LineId Id="1221" Count="2" />
      <LineId Id="1220" Count="0" />
      <LineId Id="887" Count="138" />
      <LineId Id="1169" Count="0" />
      <LineId Id="1026" Count="1" />
      <LineId Id="1231" Count="0" />
      <LineId Id="1166" Count="0" />
      <LineId Id="1029" Count="0" />
      <LineId Id="1170" Count="0" />
      <LineId Id="1030" Count="1" />
      <LineId Id="1233" Count="0" />
      <LineId Id="1172" Count="0" />
      <LineId Id="1033" Count="0" />
      <LineId Id="1171" Count="0" />
      <LineId Id="1034" Count="1" />
      <LineId Id="1234" Count="0" />
      <LineId Id="1036" Count="13" />
      <LineId Id="1235" Count="0" />
      <LineId Id="1050" Count="7" />
      <LineId Id="1173" Count="0" />
      <LineId Id="1177" Count="0" />
      <LineId Id="1176" Count="0" />
      <LineId Id="1058" Count="18" />
      <LineId Id="1185" Count="1" />
      <LineId Id="1205" Count="0" />
      <LineId Id="1189" Count="0" />
      <LineId Id="1208" Count="0" />
      <LineId Id="1190" Count="0" />
      <LineId Id="1192" Count="1" />
      <LineId Id="1215" Count="0" />
      <LineId Id="1218" Count="0" />
      <LineId Id="1216" Count="1" />
      <LineId Id="1194" Count="2" />
      <LineId Id="1199" Count="0" />
      <LineId Id="1191" Count="0" />
      <LineId Id="1187" Count="0" />
      <LineId Id="1197" Count="0" />
      <LineId Id="1226" Count="0" />
      <LineId Id="1198" Count="0" />
      <LineId Id="1200" Count="0" />
      <LineId Id="1227" Count="0" />
      <LineId Id="1230" Count="0" />
      <LineId Id="1228" Count="1" />
      <LineId Id="1201" Count="0" />
      <LineId Id="1077" Count="88" />
      <LineId Id="674" Count="0" />
    </LineIds>
    <LineIds Name="Main2.A_PreparePathPick_1">
      <LineId Id="2" Count="15" />
      <LineId Id="45" Count="0" />
      <LineId Id="20" Count="3" />
      <LineId Id="41" Count="0" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="Main2.A_PreparePathPick_2">
      <LineId Id="2" Count="13" />
      <LineId Id="49" Count="5" />
      <LineId Id="23" Count="0" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="Main2.A_PreparePathPick_3">
      <LineId Id="2" Count="12" />
      <LineId Id="24" Count="0" />
      <LineId Id="55" Count="5" />
      <LineId Id="32" Count="0" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="Main2.A_PreparePathPlace">
      <LineId Id="2" Count="13" />
      <LineId Id="50" Count="4" />
    </LineIds>
  </POU>
</TcPlcObject>